---
title: "[파이썬 알고리즘] 정렬 알고리즘 개요"
date: 2022-07-19
categories:
  - Python Algorithm
tags:
  - python
  - 알고리즘
  - 정렬
  - 선택
  - 삽입
  - 퀵
  - 계수
excerpt: "선택, 삽입, 퀵, 계수 정렬에 대해 알아보자"
---

## 정렬 알고리즘

정렬이란 **데이터를 특정한 기준에 따라 순서대로 나열하는 것**을 의미한다.

정렬 알고리즘은 프로그램을 작성할 때 가장 많이 사용되는 알고리즘 중 하나로, 이 알고리즘을 알아야 **이진 탐색**이 가능해진다고 한다.

정렬 알고리즘을 배우며 **알고리즘의 효율성**을 이해할 수 있기에 매우 중요하다고 한다.

아래 이미지에 나와있는 카드를 기준으로 선택, 삽입, 퀵, 계수 정렬이 각각 어떤 방식으로 정렬이 되는지 설명하겠다.

![card]({{ site.url }}{{ site.baseurl }}/assets/images/python/sort/card.png){: .align-center}

## 선택 정렬

선택 정렬은 매번 **가장 작은 것을 선택**하는 알고리즘으로, 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 것이다.

![selection-sort]({{ site.url }}{{ site.baseurl }}/assets/images/python/sort/selection.gif){: .align-center}

위와 같이 가장 작은 데이터를 앞으로 보내는 과정을 `N-1`번 반목하면 되고, 파이썬으로 코드를 작성한다면 아래와 같다.

{% highlight python linenos %}
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # 스와프

print(array)
{% endhighlight %}

위 코드에서 스와프란 주석이 보일 것이다.

파이썬에서는 따로 임시 저장용 변수 없이 간단히 두 원소의 위치를 변경할 수 있다.

{% highlight python linenos %}
arr = [1, 2]
arr[0], arr[1] = arr[1], arr[0] # 인덱스 0과 1의 원소 교체
print(arr) # [2, 1]
{% endhighlight %}

### 🕒 시간 복잡도

반복문이 얼마나 중첩되었는지를 기준으로 간단히 시간 복잡도를 판단할 수 있기에, 선택 정렬의 시간 복잡도는 `O(N^2)`이다.

데이터의 개수가 많아지면 많아질수록 수행 시간은 그 **제곱**으로 늘어나게된다.

아래 정렬 수행 시간을 비교한 표를 확인해보자.

| 데이터의 개수 | 선택 정렬 |  퀵 정렬 | 기본 정렬 라이브러리 |
| ------------: | --------: | -------: | -------------------: |
|           100 |   0.0123s | 0.00156s |          0.00000753s |
|         1,000 |    0.354s | 0.00343s |           0.0000365s |
|        10,000 |   15.475s |  0.0312s |            0.000248s |
{: .wide-table}

컴퓨터마다 조금씩 시간이 다를 수는 있지만, 선택 정렬이 매우 많은 시간을 잡아먹는다는 것을 알 수 있다.

> 그렇다면 왜 비효율적인 선택 정렬을 배운 것일까?

특정 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 많기 때문에 익숙해질 필요가 있다고 한다..

## 삽입 정렬

선택 정렬은 위에서 매우 비효율적이라는 것을 알게됐다.

데이터를 하나씩 확인하며 **각 데이터를 적절한 위치에 삽입**한다면 조금 더 빨라지지 않을까?

즉, 이미 정렬되어있는 데이터는 손대지 않는 것이다.

현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸는 선택 정렬과 달리 삽입 정렬은 **필요할 때만 위치를 바꾸는 알고리즘**이다.

따라서 *데이터가 거의 정렬되어 있을 때* 더욱 효과적이라고 한다.

삽입 정렬은 다시 말해 **특정한 데이터를 적절한 위치에 삽입**하는 알고리즘이고, 삽입하기 전에 그 앞까지의 데이터는 **이미 정렬되어 있다고 가정**한다.

따라서 삽입 정렬은 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하여 두 번째 데이터부터 시작한다.

![insertion-sort]({{ site.url }}{{ site.baseurl }}/assets/images/python/sort/insertion.gif){: .align-center}

위와 같은 방식으로 정렬이 되고 파이썬 코드는 아래와 같다.

{% highlight python linenos %}
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 1씩 감소하며 반복하는 문법
        if array[j] < array[j - 1]: # 한 칸씩 왼쪽으로 이동
            array[j], array[j - 1] = array[j - 1], array[j]
        else: # 자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break

print(array)
{% endhighlight %}

### 🕒 시간 복잡도

선택 정렬과 마찬가지로 반복문이 두 번 중첩되었기에 `O(N^2)`이다.

여기서 중요한 점은 삽입 정렬은 선택 정렬보다 데이터가 거의 정렬되어 있는 상태일 때 매우 빠르게 동작한다는 것이다.

최선의 경우 `O(N)`의 복잡도를 갖게 된다고 한다.

다음에 배울 퀵 정렬과 비교해서도 데이터가 거의 정렬되어 있을 경우 훨씬 더 빠르다고 한다.

따라서 **정렬이 거의 되어 있는 상태**로 문제가 주어진다면 **삽입 정렬을 이용**하도록 하자.


**Notice:** 이 게시물은 한빛미디어의 [이것이 코딩 테스트다](https://book.naver.com/bookdb/book_detail.nhn?bid=16439154) 교재를 참고하였습니다.
{: .notice--info}